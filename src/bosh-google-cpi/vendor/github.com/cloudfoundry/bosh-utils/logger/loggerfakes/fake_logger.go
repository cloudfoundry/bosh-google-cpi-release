// Code generated by counterfeiter. DO NOT EDIT.
package loggerfakes

import (
	"sync"
	"time"

	"github.com/cloudfoundry/bosh-utils/logger"
)

type FakeLogger struct {
	DebugStub        func(string, string, ...interface{})
	debugMutex       sync.RWMutex
	debugArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}
	DebugWithDetailsStub        func(string, string, ...interface{})
	debugWithDetailsMutex       sync.RWMutex
	debugWithDetailsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}
	ErrorStub        func(string, string, ...interface{})
	errorMutex       sync.RWMutex
	errorArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}
	ErrorWithDetailsStub        func(string, string, ...interface{})
	errorWithDetailsMutex       sync.RWMutex
	errorWithDetailsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}
	FlushStub        func() error
	flushMutex       sync.RWMutex
	flushArgsForCall []struct {
	}
	flushReturns struct {
		result1 error
	}
	flushReturnsOnCall map[int]struct {
		result1 error
	}
	FlushTimeoutStub        func(time.Duration) error
	flushTimeoutMutex       sync.RWMutex
	flushTimeoutArgsForCall []struct {
		arg1 time.Duration
	}
	flushTimeoutReturns struct {
		result1 error
	}
	flushTimeoutReturnsOnCall map[int]struct {
		result1 error
	}
	HandlePanicStub        func(string)
	handlePanicMutex       sync.RWMutex
	handlePanicArgsForCall []struct {
		arg1 string
	}
	InfoStub        func(string, string, ...interface{})
	infoMutex       sync.RWMutex
	infoArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}
	ToggleForcedDebugStub        func()
	toggleForcedDebugMutex       sync.RWMutex
	toggleForcedDebugArgsForCall []struct {
	}
	UseRFC3339TimestampsStub        func()
	useRFC3339TimestampsMutex       sync.RWMutex
	useRFC3339TimestampsArgsForCall []struct {
	}
	WarnStub        func(string, string, ...interface{})
	warnMutex       sync.RWMutex
	warnArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLogger) Debug(arg1 string, arg2 string, arg3 ...interface{}) {
	fake.debugMutex.Lock()
	fake.debugArgsForCall = append(fake.debugArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("Debug", []interface{}{arg1, arg2, arg3})
	fake.debugMutex.Unlock()
	if fake.DebugStub != nil {
		fake.DebugStub(arg1, arg2, arg3...)
	}
}

func (fake *FakeLogger) DebugCallCount() int {
	fake.debugMutex.RLock()
	defer fake.debugMutex.RUnlock()
	return len(fake.debugArgsForCall)
}

func (fake *FakeLogger) DebugCalls(stub func(string, string, ...interface{})) {
	fake.debugMutex.Lock()
	defer fake.debugMutex.Unlock()
	fake.DebugStub = stub
}

func (fake *FakeLogger) DebugArgsForCall(i int) (string, string, []interface{}) {
	fake.debugMutex.RLock()
	defer fake.debugMutex.RUnlock()
	argsForCall := fake.debugArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLogger) DebugWithDetails(arg1 string, arg2 string, arg3 ...interface{}) {
	fake.debugWithDetailsMutex.Lock()
	fake.debugWithDetailsArgsForCall = append(fake.debugWithDetailsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("DebugWithDetails", []interface{}{arg1, arg2, arg3})
	fake.debugWithDetailsMutex.Unlock()
	if fake.DebugWithDetailsStub != nil {
		fake.DebugWithDetailsStub(arg1, arg2, arg3...)
	}
}

func (fake *FakeLogger) DebugWithDetailsCallCount() int {
	fake.debugWithDetailsMutex.RLock()
	defer fake.debugWithDetailsMutex.RUnlock()
	return len(fake.debugWithDetailsArgsForCall)
}

func (fake *FakeLogger) DebugWithDetailsCalls(stub func(string, string, ...interface{})) {
	fake.debugWithDetailsMutex.Lock()
	defer fake.debugWithDetailsMutex.Unlock()
	fake.DebugWithDetailsStub = stub
}

func (fake *FakeLogger) DebugWithDetailsArgsForCall(i int) (string, string, []interface{}) {
	fake.debugWithDetailsMutex.RLock()
	defer fake.debugWithDetailsMutex.RUnlock()
	argsForCall := fake.debugWithDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLogger) Error(arg1 string, arg2 string, arg3 ...interface{}) {
	fake.errorMutex.Lock()
	fake.errorArgsForCall = append(fake.errorArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("Error", []interface{}{arg1, arg2, arg3})
	fake.errorMutex.Unlock()
	if fake.ErrorStub != nil {
		fake.ErrorStub(arg1, arg2, arg3...)
	}
}

func (fake *FakeLogger) ErrorCallCount() int {
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	return len(fake.errorArgsForCall)
}

func (fake *FakeLogger) ErrorCalls(stub func(string, string, ...interface{})) {
	fake.errorMutex.Lock()
	defer fake.errorMutex.Unlock()
	fake.ErrorStub = stub
}

func (fake *FakeLogger) ErrorArgsForCall(i int) (string, string, []interface{}) {
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	argsForCall := fake.errorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLogger) ErrorWithDetails(arg1 string, arg2 string, arg3 ...interface{}) {
	fake.errorWithDetailsMutex.Lock()
	fake.errorWithDetailsArgsForCall = append(fake.errorWithDetailsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("ErrorWithDetails", []interface{}{arg1, arg2, arg3})
	fake.errorWithDetailsMutex.Unlock()
	if fake.ErrorWithDetailsStub != nil {
		fake.ErrorWithDetailsStub(arg1, arg2, arg3...)
	}
}

func (fake *FakeLogger) ErrorWithDetailsCallCount() int {
	fake.errorWithDetailsMutex.RLock()
	defer fake.errorWithDetailsMutex.RUnlock()
	return len(fake.errorWithDetailsArgsForCall)
}

func (fake *FakeLogger) ErrorWithDetailsCalls(stub func(string, string, ...interface{})) {
	fake.errorWithDetailsMutex.Lock()
	defer fake.errorWithDetailsMutex.Unlock()
	fake.ErrorWithDetailsStub = stub
}

func (fake *FakeLogger) ErrorWithDetailsArgsForCall(i int) (string, string, []interface{}) {
	fake.errorWithDetailsMutex.RLock()
	defer fake.errorWithDetailsMutex.RUnlock()
	argsForCall := fake.errorWithDetailsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLogger) Flush() error {
	fake.flushMutex.Lock()
	ret, specificReturn := fake.flushReturnsOnCall[len(fake.flushArgsForCall)]
	fake.flushArgsForCall = append(fake.flushArgsForCall, struct {
	}{})
	fake.recordInvocation("Flush", []interface{}{})
	fake.flushMutex.Unlock()
	if fake.FlushStub != nil {
		return fake.FlushStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.flushReturns
	return fakeReturns.result1
}

func (fake *FakeLogger) FlushCallCount() int {
	fake.flushMutex.RLock()
	defer fake.flushMutex.RUnlock()
	return len(fake.flushArgsForCall)
}

func (fake *FakeLogger) FlushCalls(stub func() error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = stub
}

func (fake *FakeLogger) FlushReturns(result1 error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = nil
	fake.flushReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLogger) FlushReturnsOnCall(i int, result1 error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = nil
	if fake.flushReturnsOnCall == nil {
		fake.flushReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.flushReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLogger) FlushTimeout(arg1 time.Duration) error {
	fake.flushTimeoutMutex.Lock()
	ret, specificReturn := fake.flushTimeoutReturnsOnCall[len(fake.flushTimeoutArgsForCall)]
	fake.flushTimeoutArgsForCall = append(fake.flushTimeoutArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	fake.recordInvocation("FlushTimeout", []interface{}{arg1})
	fake.flushTimeoutMutex.Unlock()
	if fake.FlushTimeoutStub != nil {
		return fake.FlushTimeoutStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.flushTimeoutReturns
	return fakeReturns.result1
}

func (fake *FakeLogger) FlushTimeoutCallCount() int {
	fake.flushTimeoutMutex.RLock()
	defer fake.flushTimeoutMutex.RUnlock()
	return len(fake.flushTimeoutArgsForCall)
}

func (fake *FakeLogger) FlushTimeoutCalls(stub func(time.Duration) error) {
	fake.flushTimeoutMutex.Lock()
	defer fake.flushTimeoutMutex.Unlock()
	fake.FlushTimeoutStub = stub
}

func (fake *FakeLogger) FlushTimeoutArgsForCall(i int) time.Duration {
	fake.flushTimeoutMutex.RLock()
	defer fake.flushTimeoutMutex.RUnlock()
	argsForCall := fake.flushTimeoutArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLogger) FlushTimeoutReturns(result1 error) {
	fake.flushTimeoutMutex.Lock()
	defer fake.flushTimeoutMutex.Unlock()
	fake.FlushTimeoutStub = nil
	fake.flushTimeoutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLogger) FlushTimeoutReturnsOnCall(i int, result1 error) {
	fake.flushTimeoutMutex.Lock()
	defer fake.flushTimeoutMutex.Unlock()
	fake.FlushTimeoutStub = nil
	if fake.flushTimeoutReturnsOnCall == nil {
		fake.flushTimeoutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.flushTimeoutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLogger) HandlePanic(arg1 string) {
	fake.handlePanicMutex.Lock()
	fake.handlePanicArgsForCall = append(fake.handlePanicArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("HandlePanic", []interface{}{arg1})
	fake.handlePanicMutex.Unlock()
	if fake.HandlePanicStub != nil {
		fake.HandlePanicStub(arg1)
	}
}

func (fake *FakeLogger) HandlePanicCallCount() int {
	fake.handlePanicMutex.RLock()
	defer fake.handlePanicMutex.RUnlock()
	return len(fake.handlePanicArgsForCall)
}

func (fake *FakeLogger) HandlePanicCalls(stub func(string)) {
	fake.handlePanicMutex.Lock()
	defer fake.handlePanicMutex.Unlock()
	fake.HandlePanicStub = stub
}

func (fake *FakeLogger) HandlePanicArgsForCall(i int) string {
	fake.handlePanicMutex.RLock()
	defer fake.handlePanicMutex.RUnlock()
	argsForCall := fake.handlePanicArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLogger) Info(arg1 string, arg2 string, arg3 ...interface{}) {
	fake.infoMutex.Lock()
	fake.infoArgsForCall = append(fake.infoArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("Info", []interface{}{arg1, arg2, arg3})
	fake.infoMutex.Unlock()
	if fake.InfoStub != nil {
		fake.InfoStub(arg1, arg2, arg3...)
	}
}

func (fake *FakeLogger) InfoCallCount() int {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	return len(fake.infoArgsForCall)
}

func (fake *FakeLogger) InfoCalls(stub func(string, string, ...interface{})) {
	fake.infoMutex.Lock()
	defer fake.infoMutex.Unlock()
	fake.InfoStub = stub
}

func (fake *FakeLogger) InfoArgsForCall(i int) (string, string, []interface{}) {
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	argsForCall := fake.infoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLogger) ToggleForcedDebug() {
	fake.toggleForcedDebugMutex.Lock()
	fake.toggleForcedDebugArgsForCall = append(fake.toggleForcedDebugArgsForCall, struct {
	}{})
	fake.recordInvocation("ToggleForcedDebug", []interface{}{})
	fake.toggleForcedDebugMutex.Unlock()
	if fake.ToggleForcedDebugStub != nil {
		fake.ToggleForcedDebugStub()
	}
}

func (fake *FakeLogger) ToggleForcedDebugCallCount() int {
	fake.toggleForcedDebugMutex.RLock()
	defer fake.toggleForcedDebugMutex.RUnlock()
	return len(fake.toggleForcedDebugArgsForCall)
}

func (fake *FakeLogger) ToggleForcedDebugCalls(stub func()) {
	fake.toggleForcedDebugMutex.Lock()
	defer fake.toggleForcedDebugMutex.Unlock()
	fake.ToggleForcedDebugStub = stub
}

func (fake *FakeLogger) UseRFC3339Timestamps() {
	fake.useRFC3339TimestampsMutex.Lock()
	fake.useRFC3339TimestampsArgsForCall = append(fake.useRFC3339TimestampsArgsForCall, struct {
	}{})
	fake.recordInvocation("UseRFC3339Timestamps", []interface{}{})
	fake.useRFC3339TimestampsMutex.Unlock()
	if fake.UseRFC3339TimestampsStub != nil {
		fake.UseRFC3339TimestampsStub()
	}
}

func (fake *FakeLogger) UseRFC3339TimestampsCallCount() int {
	fake.useRFC3339TimestampsMutex.RLock()
	defer fake.useRFC3339TimestampsMutex.RUnlock()
	return len(fake.useRFC3339TimestampsArgsForCall)
}

func (fake *FakeLogger) UseRFC3339TimestampsCalls(stub func()) {
	fake.useRFC3339TimestampsMutex.Lock()
	defer fake.useRFC3339TimestampsMutex.Unlock()
	fake.UseRFC3339TimestampsStub = stub
}

func (fake *FakeLogger) Warn(arg1 string, arg2 string, arg3 ...interface{}) {
	fake.warnMutex.Lock()
	fake.warnArgsForCall = append(fake.warnArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 []interface{}
	}{arg1, arg2, arg3})
	fake.recordInvocation("Warn", []interface{}{arg1, arg2, arg3})
	fake.warnMutex.Unlock()
	if fake.WarnStub != nil {
		fake.WarnStub(arg1, arg2, arg3...)
	}
}

func (fake *FakeLogger) WarnCallCount() int {
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	return len(fake.warnArgsForCall)
}

func (fake *FakeLogger) WarnCalls(stub func(string, string, ...interface{})) {
	fake.warnMutex.Lock()
	defer fake.warnMutex.Unlock()
	fake.WarnStub = stub
}

func (fake *FakeLogger) WarnArgsForCall(i int) (string, string, []interface{}) {
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	argsForCall := fake.warnArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLogger) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.debugMutex.RLock()
	defer fake.debugMutex.RUnlock()
	fake.debugWithDetailsMutex.RLock()
	defer fake.debugWithDetailsMutex.RUnlock()
	fake.errorMutex.RLock()
	defer fake.errorMutex.RUnlock()
	fake.errorWithDetailsMutex.RLock()
	defer fake.errorWithDetailsMutex.RUnlock()
	fake.flushMutex.RLock()
	defer fake.flushMutex.RUnlock()
	fake.flushTimeoutMutex.RLock()
	defer fake.flushTimeoutMutex.RUnlock()
	fake.handlePanicMutex.RLock()
	defer fake.handlePanicMutex.RUnlock()
	fake.infoMutex.RLock()
	defer fake.infoMutex.RUnlock()
	fake.toggleForcedDebugMutex.RLock()
	defer fake.toggleForcedDebugMutex.RUnlock()
	fake.useRFC3339TimestampsMutex.RLock()
	defer fake.useRFC3339TimestampsMutex.RUnlock()
	fake.warnMutex.RLock()
	defer fake.warnMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLogger) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ logger.Logger = new(FakeLogger)
